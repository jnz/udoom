/**
 ******************************************************************************
 * @file      syscalls.c
 * @author    Auto-generated by STM32CubeIDE
 * @brief     STM32CubeIDE Minimal System calls file
 *
 *            For more information about which c-functions
 *            need which of these lowlevel functions
 *            please consult the Newlib libc-manual
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

/* Includes */
#include <sys/stat.h>
#include <stdlib.h>
#include <errno.h>
#include <stdio.h>
#include <signal.h>
#include <time.h>
#include <sys/time.h>
#include <sys/times.h>
#include <fcntl.h>   // for O_RDWR, O_WRONLY, O_CREAT, etc.
#include <unistd.h>  // for STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO
#include <string.h>  // for memcpy

/* Link fopen/fread etc. to fatfs library */
#include "ff.h"

/* Defines */
#define MAX_FILES 4
#define RESERVED_FILE_HANDLES   8

/* Functions */
extern int __io_putchar(int ch) __attribute__((weak));
extern int __io_getchar(void) __attribute__((weak));
extern int printfoutput(const char* out, int len);

/* Variables */
char *__env[1] = { 0 };
char **environ = __env;

static FIL g_files[MAX_FILES];

/* Function Bodies */

void _fini(void) {}
void __libc_init_array() {}
void initialise_monitor_handles() {}

int _getpid(void)
{
    return 1;
}

int _kill(int pid, int sig)
{
    errno = EINVAL;
    return -1;
}

void _exit(int status)
{
    _kill(status, -1);
    while (1) {}        /* Make sure we hang here */
}

int _fstat(int file, struct stat *st)
{
    st->st_mode = S_IFCHR;
    return 0;
}

int _isatty(int file)
{
    return 1;
}

int _wait(int *status)
{
    errno = ECHILD;
    return -1;
}

int _unlink(char *name)
{
    errno = ENOENT;
    return -1;
}

int _times(struct tms *buf)
{
    return -1;
}

int _stat(char *file, struct stat *st)
{
    st->st_mode = S_IFCHR;
    return 0;
}

int _link(char *old, char *new)
{
    errno = EMLINK;
    return -1;
}

int _fork(void)
{
    errno = EAGAIN;
    return -1;
}

int _execve(char *name, char **argv, char **env)
{
    errno = ENOMEM;
    return -1;
}

int _getentropy(void *buffer, size_t length)
{
    errno = ENOSYS; // Function not implemented
    return -1;
}

int _read(int file, char *ptr, int len)
{
    // Allow reading from stdin via __io_getchar (optional)
    if (file == STDIN_FILENO)
    {
        int i = 0;
        while (i < len)
        {
            if (__io_getchar)
                ptr[i++] = __io_getchar();
            else
                break;
        }
        return i;
    }

    file -= RESERVED_FILE_HANDLES;
    if (file < 0 || file >= MAX_FILES)
    {
        errno = EBADF;
        return -1;
    }

    UINT br;
    FRESULT fr = f_read(&g_files[file], ptr, len, &br);

    if (fr != FR_OK) {
        errno = EIO;
        return -1;
    }

    return br;
}

int _write(int file, char *data, int len)
{
    if (file == STDOUT_FILENO || file == STDERR_FILENO)
    {
        return printfoutput(data, len);
    }

    errno = EBADF; // not implemented
    return -1;
}

int _close(int file)
{
    if (file < RESERVED_FILE_HANDLES)
    {
        return 0;
    }
    file -= RESERVED_FILE_HANDLES;

    if(file > MAX_FILES)
    {
        errno = EBADF;
        return -1;
    }

    FRESULT res = f_close(&g_files[file]);
    if (res != FR_OK)
    {
        errno = EIO;
        return -1;
    }
    return 0;
}

int _lseek(int file, int offset, int directive)
{
    // Skip reserved file handles
    file -= RESERVED_FILE_HANDLES;
    if (file < 0 || file >= MAX_FILES)
    {
        errno = EBADF;
        return -1;
    }

    FIL *fp = &g_files[file];

    FSIZE_t new_pos;

    switch (directive)
    {
        case SEEK_SET:
            new_pos = offset;
            break;
        case SEEK_END:
            new_pos = f_size(fp) + offset;
            break;
        default:  // SEEK_CUR not supported
            errno = EINVAL;
            return -1;
    }

    FRESULT fr = f_lseek(fp, new_pos);
    if (fr != FR_OK)
    {
        errno = EIO;
        return -1;
    }

    return (int)fp->fptr;
}

int _open(const char *path, int flags, ...)
{
    BYTE fatfs_mode = 0;

    if ((flags & O_RDWR) == O_RDWR)
        fatfs_mode = FA_READ | FA_WRITE;
    else if (flags & O_WRONLY)
        fatfs_mode = FA_WRITE;
    else
        fatfs_mode = FA_READ;

#if _FS_READONLY == 0
    if (flags & O_CREAT)
        fatfs_mode |= FA_OPEN_ALWAYS;
#endif

    for (int fn = 0; fn < MAX_FILES; fn++)
    {
        if (g_files[fn].obj.fs == NULL)
        {
            FRESULT fr = f_open(&g_files[fn], path, fatfs_mode);
            if (fr == FR_OK)
            {
                return fn + RESERVED_FILE_HANDLES;
            }
            errno = EIO;
            return -1;
        }
    }
    errno = EMFILE;
    return -1;
}
