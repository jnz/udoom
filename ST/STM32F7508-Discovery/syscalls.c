/**
 ******************************************************************************
 * @file      syscalls.c
 * @author    Auto-generated by STM32CubeIDE
 * @brief     STM32CubeIDE Minimal System calls file
 *
 *            For more information about which c-functions
 *            need which of these lowlevel functions
 *            please consult the Newlib libc-manual
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

/* Includes */
#include <sys/stat.h>
#include <stdlib.h>
#include <errno.h>
#include <stdio.h>
#include <signal.h>
#include <time.h>
#include <sys/time.h>
#include <sys/times.h>
#include <fcntl.h>   // for O_RDWR, O_WRONLY, O_CREAT, etc.
#include <unistd.h>  // for STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO
#include <string.h>  // for memcpy

#define DOOM1_WAD_FILE_HANDLE_DEF       666
#define RESERVED_FILE_HANDLES           4

/* Functions */
extern int __io_putchar(int ch) __attribute__((weak));
extern int __io_getchar(void) __attribute__((weak));
extern int printfoutput(const char* out, int len);

/* Variables */
char *__env[1] = { 0 };
char **environ = __env;

extern const uint8_t _binary_wad_DOOM1_WAD_start[];
extern const uint8_t _binary_wad_DOOM1_WAD_end[];
// extern const uint32_t _binary_wad_DOOM1_WAD_size;
static int doom1_wad_file_handle = -1;
static int doom1_wad_file_offset;

/* Function Bodies */

void _fini(void) {}
void __libc_init_array() {}
void initialise_monitor_handles() {}

int _getpid(void)
{
    return 1;
}

int _kill(int pid, int sig)
{
    errno = EINVAL;
    return -1;
}

void _exit(int status)
{
    _kill(status, -1);
    while (1) {}        /* Make sure we hang here */
}

int _fstat(int file, struct stat *st)
{
    st->st_mode = S_IFCHR;
    return 0;
}

int _isatty(int file)
{
    return 1;
}

int _wait(int *status)
{
    errno = ECHILD;
    return -1;
}

int _unlink(char *name)
{
    errno = ENOENT;
    return -1;
}

int _times(struct tms *buf)
{
    return -1;
}

int _stat(char *file, struct stat *st)
{
    st->st_mode = S_IFCHR;
    return 0;
}

int _link(char *old, char *new)
{
    errno = EMLINK;
    return -1;
}

int _fork(void)
{
    errno = EAGAIN;
    return -1;
}

int _execve(char *name, char **argv, char **env)
{
    errno = ENOMEM;
    return -1;
}

int _getentropy(void *buffer, size_t length)
{
    errno = ENOSYS; // Function not implemented
    return -1;
}

int _read(int file, char *ptr, int len)
{
    if (doom1_wad_file_offset == 0 && len >= 4) {
        printf("READ start: %02x %02x %02x %02x\n",
               _binary_wad_DOOM1_WAD_start[0],
               _binary_wad_DOOM1_WAD_start[1],
               _binary_wad_DOOM1_WAD_start[2],
               _binary_wad_DOOM1_WAD_start[3]);
    }
    printf("_read: file=%d, offset=%lu, len=%d\n", file, doom1_wad_file_offset, len);

    // Allow reading from stdin via __io_getchar (optional)
    if (file == STDIN_FILENO)
    {
        int i = 0;
        while (i < len)
        {
            if (__io_getchar)
                ptr[i++] = __io_getchar();
            else
                break;
        }
        return i;
    }

    if (file != DOOM1_WAD_FILE_HANDLE_DEF + RESERVED_FILE_HANDLES)
    {
        errno = EBADF;
        return -1;
    }

    // Check if we're at or beyond end of file
    uint32_t wad_size = (uint32_t)(_binary_wad_DOOM1_WAD_end - _binary_wad_DOOM1_WAD_start);
    if (doom1_wad_file_offset >= wad_size)
    {
        return 0; // EOF
    }

    // Adjust length if it would read beyond end of file
    if (doom1_wad_file_offset + len > wad_size)
    {
        len = wad_size - doom1_wad_file_offset;
    }

    // Handle case where len becomes 0 or negative
    if (len <= 0)
    {
        return 0; // EOF
    }

    // Copy data from embedded WAD
    memcpy(ptr, _binary_wad_DOOM1_WAD_start + doom1_wad_file_offset, len);
    doom1_wad_file_offset += len;

    return len; // Return number of bytes actually read
}

int _write(int file, char *data, int len)
{
    if (file == STDOUT_FILENO || file == STDERR_FILENO)
    {
        for (int i = 0; i < len; i++)
        {
            __io_putchar(data[i]);
        }
        return len;
    }

    errno = EBADF; // not implemented
    return -1;
}

int _close(int file)
{
    if (file < RESERVED_FILE_HANDLES)
    {
        return 0;
    }
    file -= RESERVED_FILE_HANDLES;

    if(file != doom1_wad_file_handle)
    {
        errno = EBADF;
        return -1;
    }
    doom1_wad_file_handle = -1;
    doom1_wad_file_offset = 0;

    return 0;
}

int _lseek(int file, int offset, int directive)
{
    // Skip reserved file handles
    file -= RESERVED_FILE_HANDLES;
    if (file < 0 || file != doom1_wad_file_handle)
    {
        errno = EBADF;
        return -1;
    }

    uint32_t wad_size = (uint32_t)(_binary_wad_DOOM1_WAD_end - _binary_wad_DOOM1_WAD_start);
    switch (directive)
    {
        case SEEK_SET:
            doom1_wad_file_offset = offset;
            break;
        case SEEK_CUR:
            doom1_wad_file_offset += offset;
            break;
        case SEEK_END:
            doom1_wad_file_offset = wad_size + offset;
            break;
        default:
            errno = EINVAL;
            return -1;
    }

    // Allow seeking beyond end (standard behavior)
    // but ensure non-negative position
    if (doom1_wad_file_offset < 0)
    {
        doom1_wad_file_offset = 0;
        errno = EINVAL;
        return -1;
    }

    return doom1_wad_file_offset;
}

int _open(const char *path, int flags, ...)
{
    if (strcasecmp(path, "doom1.wad") == 0)
    {
        if (doom1_wad_file_handle < 0)
        {
            doom1_wad_file_handle = DOOM1_WAD_FILE_HANDLE_DEF;
            doom1_wad_file_offset = 0;
        }
        return doom1_wad_file_handle + RESERVED_FILE_HANDLES;
    }

    errno = EMFILE;
    return -1;
}
